% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{maooam Documentation}
\date{Sep 06, 2016}
\release{1}
\author{Maxime Tondeur}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Introduction}
\label{intro:introduction}\label{intro:welcome-to-maooam-s-documentation}\label{intro::doc}
Welcome to MAAOAM python documentation
\phantomsection\label{rstfiles/params2:module-params2}\index{params2 (module)}

\chapter{Maooam's parameters}
\label{rstfiles/params2:maooam-s-parameters}\label{rstfiles/params2::doc}
This module defines the parameters for the model.

\begin{notice}{note}{Note:}
The python code is available here : params2.py and on \href{https://github.com/nansencenter/DAPPER/blob/max1/mods/MAOOAM/params2.py}{Git}.
\end{notice}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{params2} \PYG{k}{import} \PYG{n}{ndim}\PYG{p}{,}\PYG{n}{natm}\PYG{p}{,}\PYG{n}{noc}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{params2} \PYG{k}{import} \PYG{n}{oms}\PYG{p}{,}\PYG{n}{nboc}\PYG{p}{,}\PYG{n}{ams}\PYG{p}{,}\PYG{n}{nbatm}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{params2} \PYG{k}{import} \PYG{o}{*}
\end{Verbatim}

There are three types of parameters :
\begin{itemize}
\item {} 
integral parameters : simulation time (transient and effective), time step, writeout and write step time

\item {} 
dimensional parameters : dimensions of the truncation of fourier for the atmosphere and the ocean

\item {} 
physical parameters : they are used in the tensor for the integration

\end{itemize}


\section{Integral parameters}
\label{rstfiles/params2:integral-parameters}
\begin{notice}{warning}{Warning:}
Time is adimensional. If t\_real is in seconds, then t\_model = t\_real * f\_0
where f\_0 is the Coriolis parameter at 45 degrees latitude ( 1.032e-4 )
\end{notice}
\begin{itemize}
\item {} 
t\_trans

\item {} 
t\_run

\item {} 
dt

\item {} 
writeout

\item {} 
tw

\end{itemize}


\section{Dimensional parameters}
\label{rstfiles/params2:dimensional-parameters}\begin{itemize}
\item {} 
oms and ams

\item {} 
nboc and natm

\item {} 
natm and noc

\item {} 
ndim

\end{itemize}

The matrices OMS and AMS gives the possible values of the modes Nx and Ny.
It is computed with nboc and natm the numbers of atmospheric and oceanic blocs.
natm and noc are the number of functions available.
ndim is the total dimension of the system.
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{oms} \PYG{o}{=}\PYG{n}{get\PYGZus{}modes}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{c+c1}{\PYGZsh{} ocean mode selection}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ams} \PYG{o}{=}\PYG{n}{get\PYGZus{}modes}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{c+c1}{\PYGZsh{} atmosphere mode selection}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{nboc}\PYG{p}{,}\PYG{n}{nbatm} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{l+m+mi}{2}          \PYG{c+c1}{\PYGZsh{} number of blocks}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{p}{(}\PYG{n}{natm}\PYG{p}{,}\PYG{n}{noc}\PYG{p}{,}\PYG{n}{ndim}\PYG{p}{)}\PYG{o}{=}\PYG{n}{init\PYGZus{}params}\PYG{p}{(}\PYG{n}{nboc}\PYG{p}{,}\PYG{n}{nbatm}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} Oceanic blocs}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}( x block number accounts for half\PYGZhy{}integer wavenumber e.g 1 =\PYGZgt{} 1/2 , 2 =\PYGZgt{} 1, etc...) }
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{OMS}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{OMS}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{OMS}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{OMS}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{OMS}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{OMS}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{OMS}\PYG{p}{[}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{OMS}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{}Atmospheric blocs}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{AMS}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{AMS}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{AMS}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{AMS}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}
\end{Verbatim}


\section{Physical parameters}
\label{rstfiles/params2:physical-parameters}
Scale parameters, ocean's and atmosphere parameters, temperature-related ocean's and atmosphere's parameters
other constants, coupling parameters


\section{Dependancies}
\label{rstfiles/params2:dependancies}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{Verbatim}


\section{Fonctions}
\label{rstfiles/params2:fonctions}
Here are the functions to generate the parameters.
\index{get\_modes() (in module params2)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/params2:params2.get_modes}\pysiglinewithargsret{\sphinxcode{params2.}\sphinxbfcode{get\_modes}}{\emph{nxmax}, \emph{nymax}}{}
Computes the matrix oms and ams with nxmax and nymax

\end{fulllineitems}

\index{init\_params() (in module params2)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/params2:params2.init_params}\pysiglinewithargsret{\sphinxcode{params2.}\sphinxbfcode{init\_params}}{\emph{nboc}, \emph{nbatm}}{}
Computes the dimensions of the system

\end{fulllineitems}

\phantomsection\label{rstfiles/ic_def:module-ic_def}\index{ic\_def (module)}

\chapter{Initial conditions generator module}
\label{rstfiles/ic_def:initial-conditions-generator-module}\label{rstfiles/ic_def::doc}
This module generates initial conditions for the model if it doesn't exist with the good dimensions.

It is possible to change the dimensions of the system in params.py the parameters file.
Then delete ic.py and ic\_def.py will regenerates it.

\begin{notice}{note}{Note:}
The python code is available here : ic\_def.py and on \href{https://github.com/nansencenter/DAPPER/blob/max1/mods/MAOOAM/ic\_def.py}{Git}.
\end{notice}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ic\PYGZus{}def} \PYG{k}{import} \PYG{n}{load\PYGZus{}IC}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{load\PYGZus{}IC}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Global file}
\label{rstfiles/ic_def:global-file}
the file ic.py in the same directory.


\section{Dependancies}
\label{rstfiles/ic_def:dependancies}
uses the modules to know the dimensions :

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{params2} \PYG{k}{import} \PYG{n}{natm}\PYG{p}{,}\PYG{n}{noc}\PYG{p}{,}\PYG{n}{ndim}\PYG{p}{,}\PYG{n}{t\PYGZus{}trans}\PYG{p}{,}\PYG{n}{t\PYGZus{}run}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{inprod\PYGZus{}analytic} \PYG{k}{import} \PYG{n}{awavenum}\PYG{p}{,}\PYG{n}{owavenum}\PYG{p}{,}\PYG{n}{init\PYGZus{}inprod}
\end{Verbatim}


\section{Functions}
\label{rstfiles/ic_def:functions}
Here is the function in the module :
\index{load\_IC() (in module ic\_def)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/ic_def:ic_def.load_IC}\pysiglinewithargsret{\sphinxcode{ic\_def.}\sphinxbfcode{load\_IC}}{}{}
Check if ic.py exists, if not creates it with good dimensions and zero initial conditions

\end{fulllineitems}



\chapter{Initial conditions module}
\label{rstfiles/ic::doc}\label{rstfiles/ic:initial-conditions-module}
This file defines the initial conditions of the model. To be deleted if the dimensions are changed.

\begin{notice}{note}{Note:}
The Code is available on \href{https://github.com/nansencenter/DAPPER/blob/max1/mods/MAOOAM/ic.py}{Git}.
\end{notice}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ic} \PYG{k}{import} \PYG{n}{X1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ic} \PYG{k}{import} \PYG{n}{X0}
\end{Verbatim}


\section{Global variables (state vectors)}
\label{rstfiles/ic:global-variables-state-vectors}\begin{itemize}
\item {} 
X1 ic computed with python after 1000 years with step time of 0.1 and GRL set of parameters

\item {} 
X0 random (non-null) initial conditions.

\end{itemize}


\section{Dependencies}
\label{rstfiles/ic:dependencies}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\end{Verbatim}
\phantomsection\label{rstfiles/inprod_analytic:module-inprod_analytic}\index{inprod\_analytic (module)}

\chapter{Inner products module}
\label{rstfiles/inprod_analytic:inner-products-module}\label{rstfiles/inprod_analytic::doc}
Inner products between the truncated set of basis functions for the ocean and 
atmosphere streamfunction fields.

\begin{notice}{note}{Note:}
These are calculated using the analytical expressions from De Cruz, L., Demaeyer,                    J. and Vannitsem, S.: A modular arbitrary-order ocean-atmosphere model: MAOOAM v1.0, Geosci. Model Dev. Discuss. 
And the \href{https://github.com/Climdyn/MAOOAM}{Fortran Code}
\end{notice}

\begin{notice}{note}{Note:}
The python code is available here : inprod\_analytic.py and on \href{https://github.com/nansencenter/DAPPER/blob/max1/mods/MAOOAM/inprod\_analytic.py}{Git}.
\end{notice}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{inprod\PYGZus{}analytic} \PYG{k}{import} \PYG{n}{init\PYGZus{}inprod} 
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{init\PYGZus{}inprod}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Global variables}
\label{rstfiles/inprod_analytic:global-variables}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{awavenum}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{natm}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{object}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{owavenum}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{n}{noc}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{n+nb}{object}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{atmos}\PYG{o}{=}\PYG{n}{atm\PYGZus{}tensors}\PYG{p}{(}\PYG{n}{natm}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{ocean}\PYG{o}{=}\PYG{n}{ocean\PYGZus{}tensors}\PYG{p}{(}\PYG{n}{noc}\PYG{p}{)}
\end{Verbatim}


\section{Dependancies}
\label{rstfiles/inprod_analytic:dependancies}
it uses the modules :

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{param2} \PYG{k}{import} \PYG{n}{nbatm}\PYG{p}{,} \PYG{n}{nboc}\PYG{p}{,} \PYG{n}{natm}\PYG{p}{,}\PYG{n}{noc}\PYG{p}{,}\PYG{n}{n}\PYG{p}{,}\PYG{n}{oms}\PYG{p}{,}\PYG{n}{ams}\PYG{p}{,}\PYG{n}{pi}
\end{Verbatim}


\section{Classes}
\label{rstfiles/inprod_analytic:classes}\begin{itemize}
\item {} 
atm\_wavenum(typ,P,N,H,Nx,Ny)

\item {} 
ocean\_wavenum(P,H,Nx,Ny)

\item {} 
atm\_tensors(natm)

\item {} 
ocean\_tensors(noc)

\end{itemize}
\index{atm\_wavenum (class in inprod\_analytic)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.atm_wavenum}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{inprod\_analytic.}\sphinxbfcode{atm\_wavenum}}{\emph{typ}, \emph{P}, \emph{M}, \emph{H}, \emph{Nx}, \emph{Ny}}{}
Class to define atmosphere wavenumbers.

Attributes :
\begin{itemize}
\item {} 
typ (char) = `A','K' or `L'.

\item {} 
M (int)

\item {} 
P (int)

\item {} 
H (int)

\item {} 
Nx (int)

\item {} 
Ny (int)

\end{itemize}

\end{fulllineitems}

\index{ocean\_wavenum (class in inprod\_analytic)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.ocean_wavenum}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{inprod\_analytic.}\sphinxbfcode{ocean\_wavenum}}{\emph{P}, \emph{H}, \emph{Nx}, \emph{Ny}}{}
Class to define ocean wavenumbers

Attributes :
\begin{itemize}
\item {} 
P (int)

\item {} 
H (int)

\item {} 
Nx (int)

\item {} 
Ny (int)

\end{itemize}

\end{fulllineitems}

\index{atm\_tensors (class in inprod\_analytic)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.atm_tensors}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{inprod\_analytic.}\sphinxbfcode{atm\_tensors}}{\emph{natm}}{}
Class which contains all the coefficients a,c,d,s,b,g needed for the tensor computation :

Attributes :
\begin{itemize}
\item {} 
\(a_{i,j}\)

\item {} 
\(c_{i,j}\)

\item {} 
\(d_{i,j}\)

\item {} 
\(s_{i,j}\)

\item {} 
\(b_{i,j,k}\)

\item {} 
\(g_{i,j,k}\)

\end{itemize}

Return :
\begin{itemize}
\item {} 
The object will be name \sphinxtitleref{atmos}.

\end{itemize}
\index{calculate\_a() (inprod\_analytic.atm\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.atm_tensors.calculate_a}\pysiglinewithargsret{\sphinxbfcode{calculate\_a}}{}{}~\begin{equation*}
\begin{split}a_{i,j} = (F_i, {\nabla}^2 F_j)\end{split}
\end{equation*}
\end{fulllineitems}

\index{calculate\_b() (inprod\_analytic.atm\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.atm_tensors.calculate_b}\pysiglinewithargsret{\sphinxbfcode{calculate\_b}}{}{}~\begin{equation*}
\begin{split}b_{i,j,k} = (F_i, J(F_j, \nabla^2 F_k])\end{split}
\end{equation*}
\begin{notice}{note}{Note:}
Atmospheric g and a tensors must be computed before calling this routine.
\end{notice}

\end{fulllineitems}

\index{calculate\_c\_atm() (inprod\_analytic.atm\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.atm_tensors.calculate_c_atm}\pysiglinewithargsret{\sphinxbfcode{calculate\_c\_atm}}{}{}~\begin{equation*}
\begin{split}c_{i,j} = (F_i, \partial_x F_j]\end{split}
\end{equation*}
\begin{notice}{note}{Note:}
Beta term for the atmosphere
Strict function !! Only accepts KL type.
For any other combination, it will not calculate anything.
\end{notice}

\end{fulllineitems}

\index{calculate\_d() (inprod\_analytic.atm\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.atm_tensors.calculate_d}\pysiglinewithargsret{\sphinxbfcode{calculate\_d}}{\emph{ocean}}{}~\begin{equation*}
\begin{split}d_{i,j} = (F_i, \nabla^2 \eta_j]\end{split}
\end{equation*}
\begin{notice}{note}{Note:}
Forcing of the ocean on the atmosphere.
Atmospheric s tensor and oceanic M tensor must be computed 
before calling this routine !
\end{notice}

\end{fulllineitems}

\index{calculate\_g() (inprod\_analytic.atm\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.atm_tensors.calculate_g}\pysiglinewithargsret{\sphinxbfcode{calculate\_g}}{}{}~\begin{equation*}
\begin{split}g_{i,j,k} = (F_i, J(F_j, F_k])\end{split}
\end{equation*}
\begin{notice}{note}{Note:}
This is a strict function: it only accepts AKL KKL and LLL types.
For any other combination, it will not calculate anything.
\end{notice}

\end{fulllineitems}

\index{calculate\_s() (inprod\_analytic.atm\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.atm_tensors.calculate_s}\pysiglinewithargsret{\sphinxbfcode{calculate\_s}}{}{}~\begin{equation*}
\begin{split}s_{i,j} = (F_i, \eta_j)\end{split}
\end{equation*}
\begin{notice}{note}{Note:}
Forcing (thermal) of the ocean on the atmosphere.
\end{notice}

\end{fulllineitems}


\end{fulllineitems}

\index{ocean\_tensors (class in inprod\_analytic)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.ocean_tensors}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{inprod\_analytic.}\sphinxbfcode{ocean\_tensors}}{\emph{noc}}{}
Class which contains all the coefficients k,m,n,w,o,c needed for the tensor computation :

Attributes :
\begin{itemize}
\item {} 
\(K_{i,j}\)

\item {} 
\(M_{i,j}\)

\item {} 
\(N_{i,j}\)

\item {} 
\(W_{i,j}\)

\item {} 
\(O_{i,j,k}\)

\item {} 
\(C_{i,j,k}\)

\end{itemize}

Return :
\begin{itemize}
\item {} 
The object will be name ocean

\end{itemize}
\index{calculate\_K() (inprod\_analytic.ocean\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.ocean_tensors.calculate_K}\pysiglinewithargsret{\sphinxbfcode{calculate\_K}}{\emph{atmos}}{}
Forcing of the atmosphere on the ocean.
\begin{equation*}
\begin{split}K_{i,j} = (\eta_i, \nabla^2 F_j)\end{split}
\end{equation*}
\begin{notice}{note}{Note:}
atmospheric a and s tensors must be computed before calling
this function !
\end{notice}

\end{fulllineitems}

\index{calculate\_M() (inprod\_analytic.ocean\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.ocean_tensors.calculate_M}\pysiglinewithargsret{\sphinxbfcode{calculate\_M}}{}{}
Forcing of the ocean fields on the ocean.
\begin{equation*}
\begin{split}M_{i,j} = (\eta_i, \nabla^2 \eta_j)\end{split}
\end{equation*}
\end{fulllineitems}

\index{calculate\_N() (inprod\_analytic.ocean\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.ocean_tensors.calculate_N}\pysiglinewithargsret{\sphinxbfcode{calculate\_N}}{}{}
Beta term for the ocean
\begin{equation*}
\begin{split}N_{i,j} = (\eta_i, \partial_x \eta_j)\end{split}
\end{equation*}
\end{fulllineitems}

\index{calculate\_O() (inprod\_analytic.ocean\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.ocean_tensors.calculate_O}\pysiglinewithargsret{\sphinxbfcode{calculate\_O}}{}{}
Temperature advection term (passive scalar)
\begin{equation*}
\begin{split}O_{i,j,k} = (\eta_i, J(\eta_j, \eta_k))\end{split}
\end{equation*}
\end{fulllineitems}

\index{calculate\_C\_oc() (inprod\_analytic.ocean\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.ocean_tensors.calculate_C_oc}\pysiglinewithargsret{\sphinxbfcode{calculate\_C\_oc}}{}{}~\begin{equation*}
\begin{split}C_{i,j,k} = (\eta_i, J(\eta_j,\nabla^2 \eta_k))\end{split}
\end{equation*}
\begin{notice}{note}{Note:}
Requires \(O_{i,j,k}\) and \(M_{i,j}\) to be calculated beforehand.
\end{notice}

\end{fulllineitems}

\index{calculate\_W() (inprod\_analytic.ocean\_tensors method)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.ocean_tensors.calculate_W}\pysiglinewithargsret{\sphinxbfcode{calculate\_W}}{\emph{atmos}}{}
Short-wave radiative forcing of the ocean.
\begin{equation*}
\begin{split}W_{i,j} = (\eta_i, F_j)\end{split}
\end{equation*}
\begin{notice}{note}{Note:}
atmospheric s tensor must be computed before calling
this function !
\end{notice}

\end{fulllineitems}


\end{fulllineitems}

\index{init\_inprod() (in module inprod\_analytic)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/inprod_analytic:inprod_analytic.init_inprod}\pysiglinewithargsret{\sphinxcode{inprod\_analytic.}\sphinxbfcode{init\_inprod}}{}{}
creates and computes the inner products.

\end{fulllineitems}



\chapter{Tensor computation module}
\label{rstfiles/aotensor:tensor-computation-module}\label{rstfiles/aotensor::doc}
The equation tensor for the coupled ocean-atmosphere model
with temperature which allows for an extensible set of modes
in the ocean and in the atmosphere.

\begin{notice}{note}{Note:}
These are calculated using the analytical expressions from De Cruz, L., Demaeyer,                    J. and Vannitsem, S.: A modular arbitrary-order ocean-atmosphere model: MAOOAM v1.0, Geosci. Model Dev. Discuss. 
And the \href{https://github.com/Climdyn/MAOOAM}{Fortran Code}
\end{notice}

\begin{notice}{note}{Note:}
The python code is available here : aotensor.py and on \href{https://github.com/nansencenter/DAPPER/blob/max1/mods/MAOOAM/aotensor.py}{Git}.
\end{notice}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{aotensor}\PYG{o}{=}\PYG{n}{aotensor}\PYG{o}{.}\PYG{n}{init\PYGZus{}aotensor}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{Help Functions}
\label{rstfiles/aotensor:help-functions}
There are ndim coordinates that correspond to 4 physical quantities.
These functions help to have the i-th coordinates of the quantity.
\begin{itemize}
\item {} 
psi(i) -\textgreater{} i

\item {} 
theta(i) -\textgreater{} i + natm

\item {} 
A(i) -\textgreater{} i + 2*natm

\item {} 
T(i) -\textgreater{} i + 2*natm + noc

\item {} 
kdelta(i,j) -\textgreater{} (i==j)

\end{itemize}


\section{Global variables}
\label{rstfiles/aotensor:global-variables}\begin{itemize}
\item {} 
real\_eps = 2.2204460492503131e-16

\item {} 
t=np.zeros( ((ndim+1),(ndim+1),(ndim+1)),dtype=float)

\end{itemize}


\section{Dependancies}
\label{rstfiles/aotensor:dependancies}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{params2} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{inprod\PYGZus{}analytic} \PYG{k}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{sparse} \PYG{k}{import} \PYG{n}{dok\PYGZus{}matrix}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{sparse} \PYG{k}{import} \PYG{n}{csr\PYGZus{}matrix}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{os}
\end{Verbatim}


\section{Functions}
\label{rstfiles/aotensor:functions}\begin{itemize}
\item {} 
compute\_aotensor

\item {} 
coeff(i,j,k,v)

\item {} 
simplify

\item {} 
init\_aotensor

\end{itemize}


\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{aotensor.}\sphinxbfcode{compute\_aotensor}}{}{}
Computes the three-dimensional tensor t

This takes the inner products of inprod\_analytic and computes the tensor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{t}} (\emph{\texttt{array((37,37,37),float)}}) -- tensor t is a global variable of aotensor

\item[{Returns}] \leavevmode
change the global tensor

\item[{Return type}] \leavevmode
void

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{compute\PYGZus{}aotensor}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{warning}{Warning:}
This needs the global variable aotensor and the global inner products to be initialized.
\end{notice}

\begin{notice}{note}{Todo}

Correct the line with sc (no impact for now)
\end{notice}

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{aotensor.}\sphinxbfcode{coeff}}{\emph{i}, \emph{j}, \emph{k}, \emph{v}}{}
Affects v for \(t_{i,j,k}\) making that tensor{[}i{]} upper triangular.
Used in compute\_aotensor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{i}} (\emph{\texttt{int in {[}1,37{]}}}) -- first coordinates

\item {} 
\textbf{\texttt{j}} (\emph{\texttt{int in {[}1,37{]}}}) -- second coodinates

\item {} 
\textbf{\texttt{k}} (\emph{\texttt{int in {[}1,37{]}}}) -- third coordinates

\item {} 
\textbf{\texttt{v}} (\emph{\texttt{float}}) -- value

\end{itemize}

\item[{Returns}] \leavevmode
change the global tensor

\item[{Return type}] \leavevmode
void

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{coeff}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,}\PYG{n}{j}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{v}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{aotensor.}\sphinxbfcode{simplify}}{}{}
Make sure that tensor{[}i{]} is upper triangular.
To do after compute\_aotensor().
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{t}} (\emph{\texttt{array((37,37,37),float)}}) -- tensor t is a global variable of aotensor

\item[{Returns}] \leavevmode
change the global tensor

\item[{Return type}] \leavevmode
void

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{simplify}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\begin{fulllineitems}
\pysiglinewithargsret{\sphinxcode{aotensor.}\sphinxbfcode{change\_structure}}{}{}
Take the 3-dimensional heavy tensor t and return aotensor a list of (i,j,k,v).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{t}} (\emph{\texttt{array((37,37,37),float)}}) -- tensor t is a global variable of aotensor

\item[{Returns}] \leavevmode
change the global tensor

\item[{Return type}] \leavevmode
void

\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{change\PYGZus{}structure}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}

\phantomsection\label{rstfiles/integrator:module-integrator}\index{integrator (module)}

\chapter{Integration module}
\label{rstfiles/integrator:integration-module}\label{rstfiles/integrator::doc}
Module with the integration
This module actually contains the Heun algorithm routines.

\begin{notice}{note}{Note:}
The python code is available here : \url{https://github.com/nansencenter/DAPPER/tree/max1/mods/MAOOAM}
\end{notice}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{integrator} \PYG{k}{import} \PYG{n}{step}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{step}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,}\PYG{n}{t}\PYG{p}{,}\PYG{n}{dt}\PYG{p}{)}
\end{Verbatim}


\section{Global variable}
\label{rstfiles/integrator:global-variable}
aotensor


\section{Dependencies}
\label{rstfiles/integrator:dependencies}
\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{mods}\PYG{n+nn}{.}\PYG{n+nn}{MAOOAM}\PYG{n+nn}{.}\PYG{n+nn}{params2} \PYG{k}{import} \PYG{n}{ndim}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{mods}\PYG{n+nn}{.}\PYG{n+nn}{MAOOAM}\PYG{n+nn}{.}\PYG{n+nn}{aotensor} \PYG{k}{as} \PYG{n+nn}{aotensor}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{sparse} \PYG{k}{import} \PYG{n}{dok\PYGZus{}matrix}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{scipy}\PYG{n+nn}{.}\PYG{n+nn}{sparse} \PYG{k}{import} \PYG{n}{csr\PYGZus{}matrix}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{import} \PYG{n+nn}{time}
\end{Verbatim}


\section{Functions}
\label{rstfiles/integrator:functions}\begin{itemize}
\item {} 
sparse\_mul3

\item {} 
tendencies

\item {} 
step

\end{itemize}
\index{sparse\_mul3() (in module integrator)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/integrator:integrator.sparse_mul3}\pysiglinewithargsret{\sphinxcode{integrator.}\sphinxbfcode{sparse\_mul3}}{\emph{arr}}{}
Calculate for each i the sums on j,k of the product
tensor(i,j,k)* arr(j) * arr(k)

\end{fulllineitems}

\index{tendencies() (in module integrator)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/integrator:integrator.tendencies}\pysiglinewithargsret{\sphinxcode{integrator.}\sphinxbfcode{tendencies}}{\emph{y}}{}
Calculate the tendencies thanks to the product of the tensor and the vector y

\end{fulllineitems}

\index{step() (in module integrator)}

\begin{fulllineitems}
\phantomsection\label{rstfiles/integrator:integrator.step}\pysiglinewithargsret{\sphinxcode{integrator.}\sphinxbfcode{step}}{\emph{y}, \emph{t}, \emph{dt}}{}
Heun method integration

\end{fulllineitems}

\phantomsection\label{rstfiles/maooam:module-maooam}\index{maooam (module)}

\chapter{Principal module}
\label{rstfiles/maooam:principal-module}\label{rstfiles/maooam::doc}
Python 3.5 implementation of the modular arbitrary-order ocean-atmosphere model MAOOAM
This module actually contains the Heun algorithm routines.

\begin{notice}{note}{Note:}
The python code is available here : \url{https://github.com/nansencenter/DAPPER/tree/max1/mods/MAOOAM}
\end{notice}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\textgreater{}\textgreater{}\textgreater{}from maooam import *


\section{Global variable}
\label{rstfiles/maooam:global-variable}
ic.X0
ic.X1
X
t
t\_trans,t\_run,tw,dt
T


\section{Dependencies}
\label{rstfiles/maooam:dependencies}
import numpy as np
import params2
from params2 import ndim,tw,t\_run,t\_trans,dt
import aotensor
import integrator
from plot import *
import time
import ic\_def
import ic


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{i}
\item {\texttt{ic\_def}}, \pageref{rstfiles/ic_def:module-ic_def}
\item {\texttt{inprod\_analytic}}, \pageref{rstfiles/inprod_analytic:module-inprod_analytic}
\item {\texttt{integrator}}, \pageref{rstfiles/integrator:module-integrator}
\indexspace
\bigletter{m}
\item {\texttt{maooam}}, \pageref{rstfiles/maooam:module-maooam}
\indexspace
\bigletter{p}
\item {\texttt{params2}}, \pageref{rstfiles/params2:module-params2}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
